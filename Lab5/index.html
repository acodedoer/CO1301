<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">
        <link rel="stylesheet" href="https://acodedoer.github.io/CO1301/assets/style.css">
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.2/styles/default.min.css">
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.2/highlight.min.js"></script>
        <!-- and it&#039;s easy to individually load additional languages -->
        <script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.2/languages/go.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
    <title>Lab 5 - Game States</title>
</head>
<body>
    <header><h1>CO1301: Games Concepts <br> Lab 5 - Game States</h1></header>
    <main>
        <section>
            <h2>1. Introduction</h2>
            <div class="section_instrcutions"></div>
                <ol>
                    <li>
                        <div class="list-div">
                                <p class= "instruction-item">
                                    In this lab you will write a bouncing sphere progam that makes uses of states to handle the sphere's bouncing movements as well as removing and recreating the sphere.
                               </p>
                           </div>
                    </li>
                </ol>
        </section>
        <section>
            <h2>2. Removing a Model from the Game Scene</h2>
            <div class="section_instrcutions"></div>
                <ol>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                Whenever we want to create a model, we use the 'CreateModel' method of an IMesh* variable. 
<pre><code>IMesh* sphereMesh = myEngine->CreateModel("Sphere.x"); //declare variable and load mesh 
IModel* sphere = sphereMesh->CreateModel( ); //declare variable and create model
</code></pre>
                                It is also possible to remove a model using the 'RemoveModel' method of its mesh. For example, the code below will remove the 'sphere' created in the code above:
<pre><code>sphereMesh->RemoveModel( sphere ); //remove model</code></pre>
                                Note that the 'RemoveModel' method is passed the IModel* variable of the model to be removed as a paramter.
                            </p>
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                The removal of a model means that it is completely destroyed. It is no longer possible to use the model since it no longer exists and, indeed, if you tried (for example) to move the model after removal you would generate a real time error.
                            </p>
                        </div>
                    </li>  
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                Although the model has been destroyed the IModel* variable still exists. This is because the IModel* variable is a particular kind of variable called a pointer, which is declared using an asterisk (*). The pointer still exists, but the removal of the model means it no longer has anything to point at. However, the IModel variable can be re-used to point to a newly created model. For example, the code below serves no real purpose but it does show this process of removing a model and reusing its IModel* variable:
<pre><code>IModel* sphere = sphereMesh->CreateModel( ); // declare variable and create model
sphereMesh->RemoveModel( sphere ); // remove model
sphere = sphereMesh->CreateModel( ); // create new model
</code></pre>
                            </p>
                        </div>
                    </li>  
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">In the next section, we will create a code that removes or creates a sphere when the 'Retun Key' is hit, based on the state of the game.
                            </p>
                        </div>
                    </li> 
                </ol>
        </section>   
        <section>
            <h2>3. Using Variables to Store Game State</h2>
            <div class="section_instrcutions"></div>
                <ol>
                    <li>
                        <div class="list-div">
                                <p class= "instruction-item">
                                    Create a new TL-Engine project named <b>Lab5_SphereStates_Project</b>.
                               </p>
                           </div>
                    </li>
                    <li>
                        <div class="list-div">
                                <p class= "instruction-item">
                                    Use Floor.x to create a floor model at the origin, then create a camera at location ( 0, 70, -100 ). You don't need to move the camera at all today so set camera type to 'kManual'.
                               </p>
                           </div>
                    </li>
                    <li>
                        <div class="list-div">
                                <p class= "instruction-item">
                                   Rotate the camera 20 units along the x axis so that it is facing downwards.
                               </p>
                           </div>
                    </li>
                    <li>
                        <div class="list-div">
                                <p class= "instruction-item">
                                    Use the sphere.x mesh to create a sphere model at ( 0, 10, 0) so that it is positioned on the floor.
                               </p>
                           </div>
                    </li>
                    <li>
                        <div class="list-div">
                                <p class= "instruction-item">
                                    Declare an integer variable called sphereState and set its value to 1. The variable should be declared outside the game loop.
                               </p>
                           </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                The logic of the program we want to code is as follows:
                                <ul>
                                    <li>If the Return key is hit and the sphereState is 1, this means that sphere exists, therefore the sphere model is removed and the sphereState is set to 0.</li>
                                    <li>If the Return key is hit and the sphereState is 0, this means that sphere does not exist, therefore the sphere model is created and the sphereState is set to 1.</li>
                                </ul>
                            </p>
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                The code to implement this looks as follows (it should be added to the game loop):
<pre><code>if( myEngine->KeyHit( Key_Return ) )
{
    if( sphereState == 1 )
    {
        sphereMesh->RemoveModel( sphere );
        sphereState = 0;
    }
    else
    {
        sphere = sphereMesh->CreateModel( 0, 10, 0 );
        sphereState = 1;
    }
}
</code></pre>
                                In this fashion you can track the state of your program. In this particular example you are keeping track of whether or not the sphere model exists. Furthermore, you are using the state of the sphere to determine what action the program needs to take: whether to create the sphere or to remove it. States are used extensively within game programming and throughout software engineering in general.
                            </p>
                        </div>
                    </li>
                </ol>
        </section>
        <section>
                <h2>2. Setting Up A Platformer</h2>
                <div class="section_instrcutions"></div>
                    <ol>
                        <li>
                            <div class="list-div">
                                    <p class= "instruction-item">
                                        In the sections to follow you will use what you have learnt so far to create an endless platformer game about a gravity defying cube.
                                    </p>
                                </div>
                        </li>
                        <li>
                            <div class="list-div">
                                    <p class= "instruction-item">
                                        Create a new TL-Engine project named <b>Lab5_GravityCube_Project</b>.
                                   </p>
                               </div>
                        </li>
                        <li>
                            <div class="list-div">
                                    <p class= "instruction-item">
                                        Download the model and texture files from the website.
                                   </p>
                               </div>
                        </li>
                        <li>
                            <div class="list-div">
                                    <p class= "instruction-item">
                                        Create a kManual camera at (0, 0, -130), and use the background.x mesh to create a background model named "background1" at position (0,0, 10).
                                   </p>
                               </div>
                        </li>
                        <li>
                            <div class="list-div">
                                    <p class= "instruction-item">
                                        Next, we need platforms for our player to move on. Use the the Platform.x mesh to create 2 platfrom models: platform1 at (0, 60, 0) and platform2 at (0, -60, 0); the platforms should be positioned in front of the wall at the top and bottom respectively.
                                   </p>
                               </div>
                        </li>
                        <li>
                            <div class="list-div">
                                    <p class= "instruction-item"> Now that we have a background and platforms to move on, it is time to add our player. Use the Player.x mesh to create a player model, the X and Z position of the player should be 0 and the Y position of the player should be such that it appears to sit on platform2, the bottom platform. Make a note of this Y position, it is the lowest position that the player should be positioned at.
                                   </p>
                               </div>
                        </li>
                    </ol>
                </section>   
                <section>
                    <h2>4. Using Enums to Store Game State</h2>
                    <div class="section_instrcutions"></div>
                        <ol>
                            <li>
                                <div class="list-div">
                                        <p class= "instruction-item">
                                            This game should be played as follows:
                                            <ul>
                                                    <li>
                                                        When the game starts the player should be positioned on the bottom platform, however when the Space Key is hit the cube should move up until it hits the top platform.
                                                    </li> 
                                                    <li>
                                                        Pressing the Space Key again should make the cube move down until it lands on the bottom platform.
                                                    </li>
                                                    <li>
                                                        Basically hitting the Space Key should make the cube move up or down continously until it hits a platform.
                                                    </li>
                                            </ul>
                                            
                                       </p>
                                   </div>
                            </li>
                            <li>
                                <div class="list-div">
                                    <p class= "instruction-item">
                                        To implement this logic, start by creating a Enumeration named EPositionState outside of the game loop for storing the two positions of the cube (Top and Bottom). Then create an enum variable of type EPositionState named playerPosition and initialise it to Bottom as you want the player to be positioned on the bottom platform when the game starts.
<pre><code>enum EPositionState {Bottom, Top};
EPositionState playerPosition = Bottom;</code></pre>
                                    </p>
                                </div>
                            </li>
                            <li>
                                <div class="list-div">
                                    <p class= "instruction-item">
                                        Next write code to check if the Space key is hit, if it is then check the playerPosition and change it change it.
<pre><code>if (myEngine->KeyHit(Key_Space)) {
    if (playerPosition == Bottom) {
        playerPosition = Top;
    }
    else {
        playerPosition = Bottom;
    }
}
</code></pre>
                                    </p>
                                </div>
                            </li>
                            <li>
                                <div class="list-div">
                                    <p class= "instruction-item">
                                        Next, define a constant float named kGravity and give it a value of 0.5f. Then in the game loop, write code to check the positionState; if the positionState is Bottom, then the cube should be moved down using MoveY(-kGravity) unitl its Y position is such that it is sitting on the bottom platform ( use the value you noted in Task 4.6 ); if the positionState is Top, then the cube should be moved up using MoveY(kGravity) unitl its Y position is such that it is just underneath the top platform ( you may have to try a few values ). The code should look like the snipet below:
                                    </p>
<pre><code>if (playerPosition == Bottom) {
    // if cube's Y is greater that the lowest Y position, move cube down some more
}
else if (playerPosition == Top){
    // if cube's Y is less that the highest Y position, move cube up some more
}
</code></pre>
                                </div>
                            </li>
                        </ol>
                </section>
                <section>
                    <h2>3. Infinite Platfroms</h2>
                    <ol>
                        <li>
                            <div class="list-div">
                                <p class= "instruction-item">
                                    Our player can swicth between the top and bottom platforms, but we still don't have a platfromer until our player is going somerwherer on these platforms.
                                </p>
                            </div>
                        </li>     
                        <li>
                            <div class="list-div">
                                <p class= "instruction-item">
                                    Rather than moving the player on the platform, it will be more efficient to move the platforms and the background to create an illusion of the player's movement. Another advantage of this is that once the platforms and the background exit the camera's view from one side they can be recycled into view from the other side to create an endless platformer. But for this approach to work we need another set of two platorms and a background image, therefore create models for platform3 at , platform4 at and background2 at.
                                </p>
                            </div>
                        </li>
                        <li>
                            <div class="list-div">
                                <p class= "instruction-item">
                                    To have a better view of how these models will be positioned and moved to create an endless platformer, change your camera type to kFPS so that you can zoom out and move around to have a better loook at all the models in the scene.
                                </p>
                            </div>
                        </li>
                        <li>
                            <div class="list-div">
                                <p class= "instruction-item">
                                    To improve efficieny, we are going to use parenting to create two sets of models each containg two platforms and a background. Therefore use the AttachToParent() method to attach platform1 and platform2 to background1; and attach platform3 and plantform4 o background2.
                                </p>
                            </div>
                        </li>  
                        <li>
                            <div class="list-div">
                                <p class= "instruction-item">
                                    When you run your program, you should notice that the position of your platforms has changed. This is beacuse when a model is attached as a child to another model, the orign of the child model is no longer the world origin but the origin of the parent model. Therefore you will have to reposition your platforms using SetLocalPosition(), the positions you provide as parameters to this function should be relative to the parent.
                                </p>
                            </div>
                        </li> 
                        <li>
                            <div class="list-div">
                                <p class= "instruction-item">
                                    All platforms should be positioned in front of their respective backgrounds; all platforms should have the same X position as their backgrounds; platform1 should be positioned 60 units above the center of background1, platform2 should be positioned 60 units below the center of background1, platform3 should be positioned 60 units above the center of background2, and platform4 should be positioned 60 units below the center of background2. 
                                </p>
                            </div>
                        </li> 
                        <li>
                            <div class="list-div">
                                <p class= "instruction-item">
                                    Next, define a constant float named kGameSpeed and initialise it to -0.05f. Then in the game loop add code to move background1 and background2 along the x axis using kGameSpeed. When you run your program, the background and platforms should be moving to the left thus creating the illusion that the cube is moving to the right.
                                </p>
                            </div>
                        </li>
                        <li>
                            <div class="list-div">
                                <p class= "instruction-item">
                                    Now we want to make sure that once a background and its models are out of view from the left, they ar erecycled so that they appear again from the right. Therefore, add code in the game loop that checks whether a set of models is out of view, if it is it should be repositioned to the right of the camera view so that they can reappear again.
<pre><code>if (background1->GetX() <= -260) {
    background1->SetPosition(260, 0, 0);
}
if (background2->GetX() <= -260) {
    background2->SetPosition(260, 0, 0);
}</code></pre>
                                </p>
                            </div>
                        </li>
                        <li>
                            <div class="list-div">
                                <p class= "instruction-item">
                                    Run your program and move your camera back so you can view how the process works. Then update your code to change your camera back to kManual positioned at (0, 0, -130).
                                </p>
                            </div>
                        </li>
                        <li>
                            <div class="list-div">
                                <p class= "instruction-item">
                                    When you run your program now you should see a cube that can jump from the bottom platform to the top and vice versa, moving on endless platforms.
                                </p>
                            </div>
                        </li> 
                    </ol>
            </section>
            <section>
                    <h2>5.Enemies on the Platform</h2>
                    <div class="section_instrcutions"></div>
                        <ol>
                            <li>
                                <div class="list-div">
                                    <p class= "instruction-item">
                                        Now that we have the infinite platform working and the the player movement also working. Let us add osme enemies.
                                    </p>
                                </div>
                            </li>
                            <li>
                                <div class="list-div">
                                    <p class= "instruction-item">
                                       We will create two enemy models, and attache one to each set of platforms and background. Create enemy1, attach it ot background1, the use SetLocalPosition to position it so that it appears on platform 2 at the center of the p;atform. Position enemy2 so that it aapears below platform 3 at the center of platform 3.
                                    </p>
                                </div>
                            </li>
                            <li>
                                <div class="list-div">
                                    <p class= "instruction-item">
                                        The enemies should now be moving with the platforms and the backgrounds.
                                    </p>
                                </div>
                            </li>
                            <li>
                                <div class="list-div">
                                    <p class= "instruction-item">
                                        To make things more exciting copy the code below and add it ito the game loop, it checks fo rcollisio betwene the player and the enemies and stops the game everytime the player hits the enemy.
                                    </p>
                                </div>
                            </li>
                        </ol>
                </section>
                <section>
                        <h2>5.Advanced</h2>
                        <div class="section_instrcutions"></div>
                            <ol>
                                <li>
                                    <div class="list-div">
                                        <p class= "instruction-item">
                                            At the moment the player can switch between position states at any time. Add an addional state to your prgram called Midway which the playe r should be in if the cube is in the process of moving from the top platform to the bottom of vice versa. The player should not be able to swicth states wjile in this state, the player should onlyu be abale tyo swich stat while in top or bottom states.
                                        </p>
                                    </div>
                                </li>
                                <li>
                                    <div class="list-div">
                                        <p class= "instruction-item">
                                           Make the player rotater 360 units along local z while in midway state, so that the player appears to flip everytime the player swicthes paltforms.
                                        </p>
                                    </div>
                                </li>
                                <li>
                                    <div class="list-div">
                                        <p class= "instruction-item">
                                            To creat ethe illusion of gravity, increase the movement speed along the way as the i sin modway so that it eappears as if gravity is pussing the player upwards or dowanlwars
                                        </p>
                                    </div>
                                </li>
                                <li>
                                    <div class="list-div">
                                        <p class= "instruction-item">
                                            Rather than stoping the enfine wwhne the pplayer collides with an enemy. Restart the game by reinitialising everything to the way it was when the game started.
                                        </p>
                                    </div>
                                </li>
                            </ol>
                    </section>

    </main>
    <script src="https://acodedoer.github.io/CO1301/assets/script.js"></script>
</body>
</html>