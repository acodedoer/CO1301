<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">
        <link rel="stylesheet" href="https://acodedoer.github.io/CO1301/assets/style.css">
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.2/styles/default.min.css">
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.2/highlight.min.js"></script>
        <!-- and it&#039;s easy to individually load additional languages -->
        <script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.2/languages/go.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
    <title>Lab 5 - State Management</title>
</head>
<body>
    <header><h1>CO1301: Games Concepts <br> Lab 5 - State Management</h1></header>
    <main>
        <section>
            <h2>1. Introduction</h2>
            <div class="section_instrcutions"></div>
                <ol>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                In this lab you will practice working with states using booleans and enums.
                            </p>
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                You will be creating a simple endless platformer as part of the lab's activites.
                            </p>
                        </div>
                    </li>
                </ol>
        </section>
        <section>
            <h2>2. Using Booleans to Store Game State</h2>
            <div class="section_instrcutions"></div>
                <ol>
                    <li>
                        <div class="list-div">
                                <p class= "instruction-item">
                                    Create a new TL-Engine project named <b>Lab5_SphereStates_Project</b>.
                               </p>
                           </div>
                    </li>
                    <li>
                        <div class="list-div">
                                <p class= "instruction-item">
                                    Use Floor.x to create a floor model at the origin, then create a camera at location ( 0, 70, -100 ). You don't need to move the camera at all today so set camera type to 'kManual'.
                               </p>
                           </div>
                    </li>
                    <li>
                        <div class="list-div">
                                <p class= "instruction-item">
                                   Rotate the camera 20 units along the x axis so that it is facing downwards.
                               </p>
                           </div>
                    </li>
                    <li>
                        <div class="list-div">
                                <p class= "instruction-item">
                                    Use the sphere.x mesh to create a sphere model at ( 0, 10, 0) so that it is positioned on the floor.
                               </p>
<pre><code>IMesh* sphereMesh = myEngine->CreateModel("Sphere.x"); //declare variable and load mesh 
IModel* sphere = sphereMesh->CreateModel(0, 10, 0 ); //declare variable and create model</code></pre>
                           </div>
                    </li>
                    <li>
                        <div class="list-div">
                                <p class= "instruction-item">
                                    Declare an boolean variable called sphereExists and set its value to "true". The variable should be declared outside the game loop.
                               </p>
                           </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                The logic of the program we want to code is as follows:
                                <ul>
                                    <li>If the Return key is hit and the sphereExists is "true", this means that sphere exists, therefore the sphere model is removed and the sphereExists is set to "false".</li>
                                    <li>If the Return key is hit and the sphereExists is "false", this means that sphere does not exist, therefore the sphere model is created and the sphereExists is set to "true".</li>
                                </ul>
                            </p>
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                It is possible to remove a model using the 'RemoveModel' method of its mesh. For example, the code below will remove the 'sphere' created earlier:
<pre><code>sphereMesh->RemoveModel( sphere ); //remove model</code></pre>
                                Note that the 'RemoveModel' method is passed the IModel* variable of the model to be removed as a paramter.
                            </p>
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                The removal of a model means that it is completely destroyed. It is no longer possible to use the model since it no longer exists and, indeed, if you tried (for example) to move the model after removal you would generate a real time error.
                            </p>
                        </div>
                    </li>  
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                Although the model has been destroyed the IModel* variable still exists. This is because the IModel* variable is a particular kind of variable called a pointer, which is declared using an asterisk (*). The pointer still exists, but the removal of the model means it no longer has anything to point at. However, the IModel variable can be re-used to point to a newly created model. For example, the code below serves no real purpose but it does show the process of removing a model and reusing its IModel* variable:
<pre><code>IModel* sphere = sphereMesh->CreateModel( ); // declare variable and create model
sphereMesh->RemoveModel( sphere ); // remove model
sphere = sphereMesh->CreateModel( ); // create new model
</code></pre>
                            </p>
                        </div>
                    </li>  
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                Back to the SphereStates project, the code to implement the program logic is as follows (it should be added to the game loop):
<pre><code>if( myEngine->KeyHit( Key_Return ) )
{
    if( sphereExists == true )
    {
        sphereMesh->RemoveModel( sphere );
        sphereExists = false;
    }
    else
    {
        sphere = sphereMesh->CreateModel( 0, 10, 0 );
        sphereExists = true;
    }
}
</code></pre>
                                In this fashion you can track the state of your program. In this particular example you are keeping track of whether or not the sphere model exists. Furthermore, you are using the state of the sphere to determine what action the program needs to take: whether to create the sphere or to remove it. States are used extensively within game programming and throughout software engineering in general.
                            </p>
                        </div>
                    </li>
                </ol>
        </section>
        <section>
            <h2>3. Using Enums to Store Game State</h2>
            <div class="section_instrcutions"></div>
                <ol>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                               Booleans are useful in handling binary states e.g. true or false, exists or does not exist, left or right, up or down etc. For more complex situations however, enumerations should be used.
                            </p>
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                               Enums offer several advantages including improved readability because since        they state what they mean and extensibility since you can easiliy add a new state as and when required.
                            </p>
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                               Let's add the ability to change the color of the sphere (by changing it's skin) while using enums to keep track of the colour state.
                            </p>
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                To implement this logic, start by creating a Enumeration named EColourStates outside of the game loop for storing the possible colours that the sphere can have, for now they should be Red, Green and Blue. Then create an enum variable of type EColourStates named sphereColour and initialise it to Red as you want the sphere to have a Red skin when the program starts.
<pre><code>enum EColourStates {Red, Green, Blue};
EColourStates sphereColour = Red;</code></pre>
                            </p>
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                Next write code to check if the Space key is hit, if it is then update sphereColour as specified below:
                                <ul>
                                    <li>if sphereColour is Red, change it to Green, and update the sphere's skin.</li>
                                    <li>if sphereColour is Green, change it to Blue, and update the sphere's skin.</li>
                                    <li>if sphereColour is Blue, change it to Red, and update the sphere's skin.</li>
                                </ul>
                                The code that implements this logic is provided below:
<pre><code>if (myEngine->KeyHit(Key_Space)) {
    if (sphereColour == Red) {
        sphereColour = Green;
        sphere->SetSkin("Green.jpg") 
    }
    else if (sphereColour == Green){
        sphereColour = Blue;
        sphere->SetSkin("Blue.jpg") 
    }
    else if (sphereColour == Blue){
        sphereColour = Red;
        sphere->SetSkin("Red.jpg") 
    }
}
</code></pre>
                            </p>
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                              You may have noticed that trying to change the colour of the sphere when it does not exists causes an error. If you haven't, then run the program, press Return so that the sphere disappears, then press Space, you should get a run time error. To fix this, the program should only only check change the skin of the sphere if the Space key is hit AND if sphereExists is true.
<pre><code>if (myEngine->KeyHit(Key_Space) && sphereExists == true) {
    if (sphereColour == Red) {
        sphereColour = Green;
        sphere->SetSkin("Green.jpg") 
    }
    else if (sphereColour == Green){
        sphereColour = Blue;
        sphere->SetSkin("Blue.jpg") 
    }
    else if (sphereColour == Blue){
        sphereColour = Red;
        sphere->SetSkin("Red.jpg") 
    }
}</code></pre>
                            </p>
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                               Using the skins provided for this lab, pdate your program so that when the Space ky is hit:
                               <ul>
                                <li>if sphereColour is Red, change it to Orange, and update the sphere's skin.</li>
                                <li>if sphereColour is Orange, change it to Yellow, and update the sphere's skin.</li>
                                <li>if sphereColour is Yellow, change it to Green, and update the sphere's skin.</li>
                                <li>if sphereColour is Green, change it to Blue, and update the sphere's skin.</li>
                                <li>if sphereColour is Blue, change it to Indigo, and update the sphere's skin.</li>
                                <li>if sphereColour is Indigo, change it to Violet, and update the sphere's skin.</li>
                                <li>if sphereColour is Violet, change it to Red, and update the sphere's skin.</li>
                            </ul>
                            </p>
                        </div>
                    </li>
                </ol>
            </section>
            <section>
                <h2>4. Separating State Transition and Action</h2>
                <div class="section_instrcutions"></div>
                <ol>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                               Let's add the ability to choose a direction for the sphere to rotate towards.
                            </p>
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                Start by creating a Enumeration named ERotationDirection outside of the game loop for storing the possible directions of rotation: Upward, Downward, Rightward, Leftward. Then create an enum variable of type ERotationDirection named sphereRotationDirection and initialise it to Rightward.
<pre><code>enum ERotationDirection {Upward, Downward, Rightward, Leftward};
ERotationDirection sphereRotationDirection = Rightward;</code></pre>
                            </p>
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                The logic we want to add to our program is as follows:
                                <ul>
                                    <li>if Right Arrow key is hit, change sphereRotationDirection to Rightward, keep rotating the sphere rightward until sphereRotationDirection is changed</li>
                                    <li>if Left Arrow key is hit, change sphereRotationDirection to Leftward, keep rotating the sphere leftward until sphereRotationDirection is changed</li>
                                    <li>if Up Arrow key is hit, change sphereRotationDirection to Upward, keep rotating the sphere upward until sphereRotationDirection is changed</li>
                                    <li>if Down Arrow key is hit, change sphereRotationDirection to Downward, keep rotating the sphere downward until sphereRotationDirection is changed</li>
                                </ul>
                            </p>
                            <p>
                                Note that the action associated with a state transition is not executed once but executed until the state changes again. Therefore, unlike in Sections 2 and 3 where the state transition and action codes were executed inside the same code block, here, you need to separate the code that handles state transitions and the code that handles the action associatd with a given state.
                            </p>
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                First, inside the game loop write code to check if the any of the Arrow Keys is hit, and update sphereRotationDirection based on the logic provided above.
<pre><code>if (myEngine->KeyHit(Key_Up)) {
    sphereRotationDirection = Upward;
}
else if (myEngine->KeyHit(Key_Down)) {
    sphereRotationDirection = Downward;
}
else if (myEngine->KeyHit(Key_Left)) {
    sphereRotationDirection = Leftward;
}
else if (myEngine->KeyHit(Key_Right)) {
    sphereRotationDirection = Rightward;
}
</code></pre>
                            </p>
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                Next, inside the game loop, write code to check the value of sphereRotationDirection and rotate the sphere accordingly.
<pre><code>if (sphereRotationDirection == Upward) {
    sphere->RotateX(rotationSpeed);
}
else if (sphereRotationDirection == Downward) {
    sphere->RotateX(-rotationSpeed);
}
else if (sphereRotationDirection == Leftward) {
    sphere->RotateY(-rotationSpeed);
}
else if (sphereRotationDirection == Leftward) {
    sphere->RotateY(rotationSpeed);
}
</code></pre>
                            </p>
                            <p>
                                Declare rotationSpeed as a float outside the game loop and assign an appropriate value to it.
                            </p>
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                                <p class= "instruction-item">
                                    Finally, you need to make sure that the sphere is only rotated if it exists to avoid a run time error. Try doing this yourself.
                                </p>
                            </div>
                    </li>
                </ol>
            </section>
            <section>
                <h2>5. State Transition Diagrams</h2>
                    <div class="list-div">
                        <p class= "instruction-item">
                           Draw 3 state transition diagrams to show the the three behaviours of the sphere that you have implemented so far (each beahviour should have its won spearate STD).
                        </p>
                    </div>
                </li>
                <p>
            </section>
        <section>
                <h2>6. Extra Exercise - Creating a Simple Platformer</h2>
                <p>Use what you have learnt so far to create an endless platformer game about a gravity defying cube. You can do this within or outside of the lab session. <a target="_blank" href="">Click here to begin.</a> </p>
                    </section>

    </main>
    <script src="https://acodedoer.github.io/CO1301/assets/script.js"></script>
</body>
</html>