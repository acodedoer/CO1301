<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">
        <link rel="stylesheet" href="https://acodedoer.github.io/CO1301/assets/style.css">
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.2/styles/default.min.css">
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.2/highlight.min.js"></script>
        <!-- and it&#039;s easy to individually load additional languages -->
        <script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.2/languages/go.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
    <title>Lab 5 - Game States</title>
</head>
<body>
    <header><h1>CO1301: Games Concepts <br> Lab 5 - Game States</h1></header>
    <main>
        <section>
            <h2>1. Introduction</h2>
            <div class="section_instrcutions"></div>
                <ol>
                    <li>
                        <div class="list-div">
                                <p class= "instruction-item">
                                    In this lab you will write a bouncing sphere progam that makes uses of states to handle the sphere's bouncing movements as well as removing and recreating the sphere.
                               </p>
                           </div>
                    </li>
                </ol>
        </section>
        <section>
            <h2>2. Removing a Model from the Game Scene</h2>
            <div class="section_instrcutions"></div>
                <ol>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                Whenever we want to create a model, we use the 'CreateModel' method of an IMesh* variable. 
<pre><code>IMesh* sphereMesh = myEngine->CreateModel("Sphere.x"); //declare variable and load mesh 
IModel* sphere = sphereMesh->CreateModel( ); //declare variable and create model
</code></pre>
                                It is also possible to remove a model using the 'RemoveModel' method of its mesh. For example, the code below will remove the 'sphere' created in the code above:
<pre><code>sphereMesh->RemoveModel( sphere ); //remove model</code></pre>
                                Note that the 'RemoveModel' method is passed the IModel* variable of the model to be removed as a paramter.
                            </p>
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                The removal of a model means that it is completely destroyed. It is no longer possible to use the model since it no longer exists and, indeed, if you tried (for example) to move the model after removal you would generate a real time error.
                            </p>
                        </div>
                    </li>  
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                Although the model has been destroyed the IModel* variable still exists. This is because the IModel* variable is a particular kind of variable called a pointer, which is declared using an asterisk (*). The pointer still exists, but the removal of the model means it no longer has anything to point at. However, the IModel variable can be re-used to point to a newly created model. For example, the code below serves no real purpose but it does show this process of removing a model and reusing its IModel* variable:
<pre><code>IModel* sphere = sphereMesh->CreateModel( ); // declare variable and create model
sphereMesh->RemoveModel( sphere ); // remove model
sphere = sphereMesh->CreateModel( ); // create new model
</code></pre>
                            </p>
                        </div>
                    </li>  
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">In the next section, we will create a code that removes or creates a sphere when the 'Retun Key' is hit, based on the state of the game.
                            </p>
                        </div>
                    </li> 
                </ol>
        </section>   
        <section>
            <h2>3. Using Variables to Store Game State</h2>
            <div class="section_instrcutions"></div>
                <ol>
                    <li>
                        <div class="list-div">
                                <p class= "instruction-item">
                                    Create a new TL-Engine project named <b>Lab5_SphereStates_Project</b>.
                               </p>
                           </div>
                    </li>
                    <li>
                        <div class="list-div">
                                <p class= "instruction-item">
                                    Use Floor.x to create a floor model at the origin, then create a camera at location ( 0, 70, -100 ). You don't need to move the camera at all today so set camera type to 'kManual'.
                               </p>
                           </div>
                    </li>
                    <li>
                        <div class="list-div">
                                <p class= "instruction-item">
                                   Rotate the camera 20 units along the x axis so that it is facing downwards.
                               </p>
                           </div>
                    </li>
                    <li>
                        <div class="list-div">
                                <p class= "instruction-item">
                                    Use the sphere.x mesh to create a sphere model at ( 0, 10, 0) so that it is positioned on the floor.
                               </p>
                           </div>
                    </li>
                    <li>
                        <div class="list-div">
                                <p class= "instruction-item">
                                    Declare an integer variable called sphereState and set its value to 1. The variable should be declared outside the game loop.
                               </p>
                           </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                The logic of the program we want to code is as follows:
                                <ul>
                                    <li>If the Return key is hit and the sphereState is 1, this means that sphere exists, therefore the sphere model is removed and the sphereState is set to 0.</li>
                                    <li>If the Return key is hit and the sphereState is 0, this means that sphere does not exist, therefore the sphere model is created and the sphereState is set to 1.</li>
                                </ul>
                            </p>
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                The code to implement this looks as follows (it should be added to the game loop):
<pre><code>if( myEngine->KeyHit( Key_Return ) )
{
    if( sphereState == 1 )
    {
        sphereMesh->RemoveModel( sphere );
        sphereState = 0;
    }
    else
    {
        sphere = sphereMesh->CreateModel( 0, 10, 0 );
        sphereState = 1;
    }
}
</code></pre>
                                In this fashion you can track the state of your program. In this particular example you are keeping track of whether or not the sphere model exists. Furthermore, you are using the state of the sphere to determine what action the program needs to take: whether to create the sphere or to remove it. States are used extensively within game programming and throughout software engineering in general.
                            </p>
                        </div>
                    </li>
                </ol>
        </section>
        <section>
            <h2>4. Using Enums to Store Game State</h2>
            <div class="section_instrcutions"></div>
                <ol>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                            enums are a more elegant way of defining values for states in C++. 
                            </p>
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                            We are going to update the program so that the sphere bounces up and down between y = 50 and y = 10. But we have to make sure this only happens when the sphereState is 1 i.e. when the sphere is not removed (since attempting to move the sphere after it has been removed will cause an error).
                            </p>
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                            Create a Enumeration named EDirectionState outside of the game loop for storing the two directions of movement we are interested in. Then create an enum variable of type EDirectionState named sphereDirection and initialise it to Up as you want the sphere to be moving Up when the game starts.
<pre><code>enum EDirectionState {Up, Down};
EDirectionState sphereDirection = Up;</code></pre>
                            </p>
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                            Now inside the game loop write code to check check whether the sphere exists, if it does then check the sphereDirection state and move the sphere based on its value.
                            </p>

<pre><code>if ( sphereState == 1 ) { //if sphere exists
    if ( sphereDirection == Up ){ 
        sphere->MoveY (0.1);      
    }
    else if ( sphereDirection == Down ){  
        sphere->MoveY (-0.1);             
    }
}
</code></pre>
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                            Finally, below the code froom the last step, add code to check for the event that should change the sphereDirection state (by checking the Y position of the sphere). This should also only happen if the sphere is not removed, otherwise an error will occur. 
                            </p>

<pre><code>if ( sphereState == 1 ) { //if sphere exists
    if ( sphere->GetY() >= 60 ){
        sphereDirection = Down;
    }
    else if ( sphere->GetY() <= 10  ){
        sphereDirection = Up;
    }
}
</code></pre>
                        </div>
                    </li>
                </ol>
        </section>
        <section>
            <h2>5. Advanced Exercise</h2>
                <ol>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                Utilise states and parenting to create a simple platformer game in this advanced exercise sheet.
                            </p>
                        </div>
                    </li>
                </ol>
        </section>

    </main>
    <script src="https://acodedoer.github.io/CO1301/assets/script.js"></script>
</body>
</html>