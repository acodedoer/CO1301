<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="https://acodedoer.github.io/CO1301/assets/style.css">
    <link rel="stylesheet"
    href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.2/build/styles/default.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.2/build/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <title>CO1301 Assessment 1 - Spheres.io Implementation Guide</title>
    <style>
        div{
            margin-bottom: 2em;
        }
    </style>
</head>
<body>
    <header><h1>CO1301: Games Concepts <br> Assessment 1 - Spheres.io Implementation Guide</h1></header>
    <main>
        <section>
            <div>
                This document is not meant to serve as an <a href="https://portal.uclan.ac.uk/bbcswebdav/courses/CO1301_202122_1_9/Assessment1/CO1301%20Assessment%201%20Brief%202021-2022.pdf">Assessment Brief</a> or its replacement, it is simply meant to help guide those that seek guidance through implementing the features specified in the <a href="https://portal.uclan.ac.uk/bbcswebdav/courses/CO1301_202122_1_9/Assessment1/CO1301%20Assessment%201%20Brief%202021-2022.pdf">Assessment Brief</a>, <b>make sure you read and understand the brief before reading this document</b>. Those that do not seek guidance can ignore this document completely, or turn towards it only in time of dire need. Note that it is completely acceptable for your implementation approach to differ from what is described in this document, as long as it meets the specifications of the <a href="https://portal.uclan.ac.uk/bbcswebdav/courses/CO1301_202122_1_9/Assessment1/CO1301%20Assessment%201%20Brief%202021-2022.pdf">Assessment Brief</a>.
            </div>
            <div>
                <b>1. BASIC LAYOUT</b>
                <p>Setting up the basic scene requires loading the meshes provided, creating appropriate models, and positioning the models as specified by the brief. You should have completed similar tasks in every lab since Lab1 of this module, for example, see your solution for section 2 of Lab5 or Lab5's walkthrough video. On implementing the basic layout as specified, your scene should look like the image below.</p>
                <img class="center" src="https://acodedoer.github.io/CO1301/Assessment1/basiclayout.png">
            </div>

            <div>
                <b>2. MILESTONE 1: THIRD CLASS (UPTO 49%)</b>
                <p>You must have implemented the basic scene as specified by the brief to get full marks for implementing features in this section. The features in this milestone can be implemented as described below, and on completion, the game should look similar to the video that follows.
                    <ul>
                        <li>
                            To implement WASD controls for moving the sphere and arrow controls for the camera use <b>Lab2_Controls_Project</b> and <b>Lab3_CameraControl_Project</b> as references.
                        </li>
                        <li>
                            To check whether the sphere has moved into the water, use <b>Lab2_TestingVariables_Project</b> as a reference.
                        </li>
                        <li>
                            To implement Paused and Playing states, you can use a boolean variable to store this binary state (use <b>Lab2_TestingVariables_Project</b> as a reference). However, if you are implementing features up to MILESTONE 3 or higher, you must utilise an enumeration to track the states of the game i.e. Playing, Paused and GameOver, use <b>Lab5_SphereStates_Project</b> as a reference. For this milestone, the game should just end when it enters GameOver state.
                        </li>
                        
                        <li>
                            To implement box pickup by the sphere, you have to calculate the distance between the sphere and the all the cubes in the scene at every frame by doing the following for each cube in the scene:
                            <ol>
                                <li>
                                    Calculate the vector between the sphere and the cube
                                </li>
                                <li>
                                    Calculate the length of the vector, this is the distance between the sphere and the cube
                                </li>
                                <li>
                                    If the distance is less than the sum of the sphere radius (10) and half of the cube's side length (2.5), then the cube should be picked up.
                                </li>
                                <li>
                                    Make the cube invisible, you can do that by changing its position to be out of view.
                                </li>
                            </ol>
                            Vectors are introduced  in Lecture 6 - Vectors, you can use the formula introduced to calculate the vector between the sphere and each cube, and their lengths. You can also use <b>Lab7_Drone_Project</b> as a reference. However note that <b>Lab7_Drone_Project</b> goes on to calculate direction vectors, for this assessment you are only interested in calculating the length of a vector and comparing it to some distance.
                        </li>
                    </ul>
                </p>
                <iframe class="center" width="640" height="360" src="https://web.microsoftstream.com/embed/video/fa759196-bdde-48e9-87f9-2de00b946eff?autoplay=false&showinfo=true" allowfullscreen style="border:none;"></iframe>
            </div>
    
            <div>
                <b>3. MILESTONE 2: LOWER SECOND CLASS (UPTO 59%)</b>
                <p>You must have implemented the basic scene as specified by the brief, and <b>MILESTONE 1</b> to get full marks for implementing features in this section. The features in this milestone can be implemented as described below, and on completion, the game should look similar to the video that follows.
                <ul>
                    <li>
                        To implement an isometric camera on pressing "2", listen for a key hit on the 2 key, and update the position and rotation of the camera as specified by the brief. It is important that you first reset the orientation of the camera before making these updates (use <b>camera->ResetOrientation()</b>). If the isometric camera is active, listen for key hit on the 1 key to update the position and rotation back to the top-down camera specified in the basic scene spec, again remember to reset the orientation before making the updates. Also remember that the arrow controls should not work on the camera if it is isometric, therefore you may have to use states to track the active camera, <b>Lab5_SphereStates_Project</b> can be used as a reference for this.
                    </li>
                    <li>
                        To implement point keeping, declare a variable for storing points and increment its value every time a box is picked up i.e. every time the distance between the sphere and a box is small enough. To display the points on the screen, use <b>Lab4_KeepingScore_Project</b> as a reference
                    </li>
                    <li>
                        To implement sphere resize, you need to keep track of the number of cuved picked up by the sphere (e.g. using a counter or even using the score). If 4 spheres are picked, use the <b>sphere->Scale(x)</b> to increase the scale of the sphere to 1.2 its initial size. To ensure parts of the sphere are not below the floor after reseize, the y-position of the sphere must also be scaled by 1.2.
                    </li>
                </ul>
                <iframe class="center" width="640" height="360" src="https://web.microsoftstream.com/embed/video/bdc34a3e-a54f-4414-a813-7d174a447ee4?autoplay=false&showinfo=true" allowfullscreen style="border:none;"></iframe>
            </div>

            <div>
                <b>4. MILESTONE 3: UPPER SECOND CLASS (UPTO 59%)</b>
                <p>You must have implemented the basic scene as specified by the brief, <b>MILESTONE 1</b> and <b>MILESTONE 2</b> to get full marks for implementing features in this section. The features in this milestone can be implemented as described below, and on completion, the game should look similar to the video that follows.
                <ul>
                    <li>
                        To implement an array for storing 12 cube models, use <b>Lab6_Vectors_Project</b> as a reference. Remember, you now need to scale the cube to 1.2 its initial size every time it picks up 4 cubes. You may also notice a reduction in the speed of your game due to the additional cubes and the increased number of collision check calculations, to remove this effect, start utilising variable timing to move and rotate the sphere, use <b> Lab7_Drones_Project</b> as a reference.
                    </li>
                    <li>
                        To implement random positions for the cubes, you must utilise some random function to generate random x and z positions for each cube (y-position should be the same for all cubes), these random positions must be restricted to values that will place the cube on the floor. The values should be generated and used to position the cubes in the same loop that creates them and stores them in the array implemented above. You can use <b>CO1404's Lab 3 </b> as a reference for generating random numbers or look up C++'s rand() function.
                    </li>
                    <li>
                        To implement sphere to box collision detection, use <b>Lab8_BoxCollisions_Project</b> as a reference (this will be available to you on 17/12/2021.
                    </li>
                    <li>
                        For this milestone, you must track the four game states, Playing, Paused, GameOver and GameWon, using an enumeration; use <b>Lab5_SphereStates_Project</b> as a reference. Movement should only be allowed in the Playing state, everything should be paused in the Pause state, and appropriate messages should be displayed in GameOver and GameWon states.
                    </li>
                </ul>
                <iframe class="center" width="640" height="360" src="https://web.microsoftstream.com/embed/video/1991bc6e-dbf1-4f81-bea0-929967854e22?autoplay=false&showinfo=true" allowfullscreen style="border:none;"></iframe>
            </div>

            <div>
                <b>5. MILESTONES 4 & 5:  FIRST CLASS ( 70%+)</b>
                <p>You must have implemented the basic scene as specified by the brief, <b>MILESTONE 1</b>, <b>MILESTONE 2</b> and <b>MILESTONE 3</b> to get full marks for implementing features in this section. The features in this milestone can be implemented as describe below, and on IMPLEMTING , <b>MILESTONE 4</b> features the game should look similar to the video that follows. No video is provided for <b>MILESTONE 5</b> as the milestone allows creative flexibility. 
                <ul>
                    <li>
                        To implement the separation between spawned cubes, use a while loop to keep generating random positions for each cube to be spawned until the position generated is more than 10 units away from all other cubes spawned and the sphere. This means that for each cube to be spawned, you need to: generate a random x and z values to crete a random position, calculate the vector between the random position and the position of all cubes that have been spawned, calculate the length of the vector, while the length is less than 10 repeat the process. Revisit <b>CO1404's Lab4 and Lab5</b> sheets and solutions for a reminder on while loops, you can think of this task as using a while loop to validate the random position generated.
                    </li>
                    <li>
                        To implement random respawn, you will have to use the same process described above to find create a new position for a cube that is picked up by the sphere (Instead of hiding it as done in previous milestones)
                    </li>
                    <li>
                        To implement "Hpper Mode", you will need to utilise states to track whether the sphere is in regular or hyper mode. In hyper mode, the sphere skin should change, and in addition to the sphere to box collision detection for box pickup, you also need to perform distance checks between all cubes and the sphere and have every cube within 50 units of the sphere moved towards the sphere. A cube moving towards the sphere does not get picked up until it gets close enough to the shere for the sphere to box collision to come into effect.
                    </li>
                    <li>
                        Hper mode should last five seconds, the sphere should return to its regulaar state after that.To implement this, remember that the Timer() method returns the time that has passed since the last frame was rendered (in milliseconds).
                    </li>
                    <li>
                        The NPC sphere should move in some intelligent or at least random manner, be able to pick up cubes like the player sphere, increase in size after every 4 pickups, should not move off the floor, and should be able to enter Hyper Mode. Use sphere to sphere collision detection to check for collisions between the two spheres and determine the resolution based on their points, as specified by the brief. 
                    </li>
                </ul>
                <iframe class="center" width="640" height="360" src="https://web.microsoftstream.com/embed/video/a3d59a78-b317-4a7c-81c6-f83dda9ce5df?autoplay=false&showinfo=true" allowfullscreen style="border:none;"></iframe>
            </div>

        </section>
    </main>
</body>
</html>
