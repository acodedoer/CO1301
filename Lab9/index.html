<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="https://acodedoer.github.io/CO1301/assets/style.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.2/styles/default.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.2/highlight.min.js"></script>
    <!-- and it&#039;s easy to individually load additional languages -->
    <script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.2/languages/go.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <title>CO1301 Lab 9: Parenting & the Solar System</title>
</head>
<body>
    <header><h1>CO1301: Games Concepts <br>Lab 9 - Parenting  & the Solar System</h1></header>
    <main>
        <section>
            <section>
                <h2>1. Introduction</h2>
                <div class="section_instrcutions"></div>
                    <ol>
                        <li>
                            <div class="list-div">
                                    <p class= "instruction-item">In this lab, we will look at how two objects (e.g. models and cameras) can be linked to form parent/child relationships.
                                   </p>
                               </div>
                        </li>
                        <li>
                            <div class="list-div">
                                    <p class= "instruction-item">There are a huge number of possibilities to this technique: for example, attaching a gun object to a character object, allowing a character to move around on a moving boat, or making a camera follow a character around (chase view).
                                   </p>
                               </div>
                        </li>
                        <li>
                            <div class="list-div">
                                <p class= "instruction-item">
                                    This lab will also introduce the idea of parenting, model hierarchy, and the dummy model.
                                </p>
                            </div>
                        </li>
                    </ol>
            </section>
            <section>
                <h2>2. Parenting</h2>
                <div class="section_instrcutions"></div>
                    <ol>
                        <li>
                            <div class="list-div">
                                    <p class= "instruction-item">Create a new TL-Engine project named <b>Lab9_Parenting_Project</b>. Open the project.
                                    </p>
                                </div>
                        </li>
                        <li>
                            <div class="list-div">
                                <p class= "instruction-item">Load the grid mesh, the cube mesh and create a model for each of them at the origin.
                                        
                                </p>
                            </div>
                        </li>
                        <li>
                                <div class="list-div">
                                    <p class= "instruction-item">Load the sphere mesh and create a sphere model at position (-30, 0, -10).
                                    </p>
                                </div>
                            </li>
                        <li>
                            <div class="list-div">
                                <p class= "instruction-item">Add code to allow you to move the cube using the keyboard (using w, a, s, and d keys).
                                </p>
                            </div>
                        </li>
                        <li>
                            <div class="list-div">
                                <p class= "instruction-item">Now attach the sphere model to the cube model using the AttachToParent() method as shown below, the code should be added in the initialisation section. The sphere should then follow the cube when it moves.
                                    <pre><code>sphere->AttachToParent(cube);</code></pre>
                                You can view the method's definition in the appendix section at the end of this document.
                                </p>

                            </div>
                        </li>
                        <li>
                            <div class="list-div">
                                <p class= "instruction-item">Now add code to allow you to move the sphere (using u, h, j, and k keys). Do you understand how it moves relative to the cube?
                                </p>
                            </div>
                        </li>
                        <li>
                            <div class="list-div">
                                <p class= "instruction-item">Now change the camera to a "kManual" type and then attach the camera to the cube (the kFPS type of camera will not work here).
                                </p>
                            </div>
                        </li>
                        <li>
                            <div class="list-div">
                                <p class= "instruction-item">Next change the position of the camera, using the SetLocalPosition() method, to (0.0f, -30.0f, 50.0f); and rotate the camera about its local x-axis by 30 degrees. You should now have a basic chase view camera.
                                </p>
                            </div>
                        </li>
                        <li>
                            <div class="list-div">
                                <p class= "instruction-item">Finally, implement functionality to detach the sphere from the cube when the Space key is hit, or attach the sphere to the cube (if the sphere is detached when the Space Key is hit). The code for attaching the sphere to the cube has already been introduced in 2.5, below is the code for detaching an object from its parent.</p>
                                <pre><code>object->DetachFromParent();  // DetachFromParent() detaches object from any parent it is attached to</code></pre>
                                <p>You will need to declare a boolean or an enumeration to keep track of the state of the shere (attached or detached).</p>
  
                                </p>
                            </div>
                        </li>
                        <li>
                            <div class="list-div">
                                <p class= "instruction-item">Save your project.
                                </p>
                            </div>
                        </li>
                    </ol>
                </div>
                </section>
        <section>
            <h2>3. Solar System Project </h2>
            <div class="section_instrcutions"></div>
                <ol>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                Let's use what we have introduced in the first part of this lab to create a mini solar system. Start by creating a new TL-Engine project called <b>Lab9_SolarSystem_Project</b>. 
                            </p>
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                Use the "Stars.x" mesh to create a model at the origin that will serve as a skybox. Its radius is 100, and when placed in your scene it will create a background of stars. The model also has some alternative skins:
                                <ul>
                                    <li>“StarsHi.jpg”</li>
                                    <li>“StarClouds.jpg”</li>
                                    <li>“StarCloudsHi.jpg”</li>
                                </ul>
                            </p>
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                The "Planet.x" mesh can be used to create spheres with a radius of 1.0 and has several basic skins to create all the main bodies in the solar system:
                                <ul>
                                    <li>“Sun.jpg”</li>
                                    <li>“Mercury.jpg”</li>
                                    <li>“Venus.jpg”</li>
                                    <li> “Earth.jpg”</li>
                                    <li>“Moon.jpg”</li>
                                    <li>“Mars.jpg”</li>
                                    <li>“Jupiter.jpg”</li>
                                    <li> “Saturn.jpg”</li>
                                    <li>“Uranus.jpg”</li>
                                    <li>“Neptune.jpg”</li>
                                    <li>“Pluto.jpg”</li>
                                </ul>
                             <br>
                                <p>There are also some additional and hi-resolution skins:</p>
  
                                <ul>
                                    <li>“EarthHi.jpg”</li>
                                    <li>“EarthPlain.jpg”</li>
                                    <li>“EarthNight.jpg”</li>
                                    <li>“EarthPlainHi.jpg”</li>
                                    <li>“EarthNightHi.jpg”</li>
                                    <li>“MoonHi.jpg”</li>
                                </ul>
                            </p>
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                You can use TL-Engine scaling functions ( Scale() ) to make models larger or smaller. This will allow you to use the same planet mesh to create models for the Sun, the Earth and all the other planets - you scale each one differently to create appropriate sizes.
                            </p>
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                There is also another engine function SetFarClip that changes how far away you can see. In a space game you can see very far so this is needed, use it when objects are “clipped” in the distance:
                            </p>
                            <pre><code>myCamera->SetFarClip( 100000 ); // Now can see up to 100k distant</code></pre>
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                Begin by creating the earth (at the origin) and the moon (to the earth's side) using the "Planet.x" mesh and the appropriate texture for each body. Place them close enough together so that you can see them both comfortably (remember, this is not meant to be realistic). You will have to scale the  model down for the moon.
                            </p>
                            <p>
                                You may want to set the y-position of your camera to 0 so that the models are centred within the camera's view.
                            </p>
                            <img src="https://acodedoer.github.io/CO1301/Lab9/earthandmoon.JPG" alt="a picture of the models of earth and moon"/>
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                In your game-loop add code that rotates the Earth about its local y-axis.
                            </p>
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                Attach the moon as a child of the earth using the AttachToParentMethod() as shown below:
                            </p>
                            <pre><code>moon->AttachToParent( earth );</code></pre>
                            <p>This means that the earth model is now a parent of the moon model, and the moon's position is now relative to the position of the earth (therefore, you may need to adjust the coordinates used to position the moon beside the earth). You should now see the moon revolving around the earth when you run your program.</p>
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                This is all well and good, but what would happen if you wanted the earth and the moon to rotate at different speeds? The way things are set up at the moment the earth must rotate around its axis at the same speed that the moon rotates around the earth. It is possible to set up the scene so that the earth and the moon rotate at different speeds and this is by introducing a dummy model using the "Dummy.x" mesh. You load and use the dummy model in exactly the same way as any other mesh and model. The difference is that the dummy is never rendered: it is just an invisible point in space.
                            </p>
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                Create a dummy model at the same location as the earth. Attach the moon to the dummy instead of the earth.
<pre><code>IMesh* dummyMesh = myEngine->LoadMesh("Dummy.x");
IModel* dummy = dummyMesh->CreateModel(earth->GetX(), earth->GetY(), earth->GetZ());
moon->AttachToParen(dummy);</code></pre>
                            </p>
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                In the game loop add code that rotates the dummy about its local y-axis. Now you can rotate the Earth separately from the dummy (and hence the moon).
                            </p>
                        </div>
                    </li>
                </ol>
            </section>
            <section>
                <h2>4. Adding Bodies</h2>
                <div class="section_instrcutions"></div>
                    <ol>
                         <li>
                            <div class="list-div">
                                <p class= "instruction-item">
                                    Let us expand what we have so far to a mini solar system.
                                </p>
                            </div>
                        </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                Create a model for the sun using the Planet.x mesh, place it at the origin (you will need to reposition the earth in the next step), scale the sun to show its size compared to the earth (again it should just be bigger, not realistic), and use the appropriate skin.
                            </p>
                        </div>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                Change the position of your earth, moon and dummy models with respect to the position of the sun. Remember the dummy should be in the same position as the earth; and the moon is a child of the dummy, therefore you will need to position it relative to the position of the dummy.
                            </p>
                            <img src="https://acodedoer.github.io/CO1301/Lab11/sunandearth.jpg" alt="a picture of the models of the sun, earth and moon"/>
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                Add a few other planets around the sun and scale them to different sizes. You don’t need to worry about getting the sizes of the planets correct, just try to make it look interesting.
                            </p>
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                Make the planets orbit realistically (they rotate around the sun at different speeds and spin on their axes). You will need to think about using parenting and dummy objects.
                            </p>
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                You will need to think carefully about the scales and distances that you use. Try to make your scene look good but feel suitably large without being impossible to navigate. Note that your solar system does not have to look like what is shown in the images in this lab sheet.
                            </p>
                        </div>
                    </li>           
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                For future reference, you are formally building an animation hierarchy. Your program uses the same concepts and general form that you would to build an animation hierarchy e.g. for a person.
                            </p>
                        </div>
                    </li>
                </ol>
            </section>
            <section>
                <h2>5. Spaceship and Chase Camera</h2>
                <div class="section_instrcutions"></div>
                    <ol>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                Load up and create a spaceship. The model can be found inside <a href="https://portal.uclan.ac.uk/bbcswebdav/courses/CO1301_202122_1_9/Labs_HTML/Lab9/spaceship.zip">"spaceship.zip" from this link</a>. You may have to scale this up or down depending on the size of your planets.
                            </p>
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                Implement movement control for the spaceship using W for forward movement (local z-axis), and A and D for rotation about its local y-axis.
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                Create a chase camera by attaching your camera to the spaceship, and then positioning the camera behind the spaceship. Make sure your camera is a kManual camera (see section 2 for a reminder on how to do this).
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                Implement collision detection and an appropriate collision resolution for the spaceship and the sun only. Use sphere bounding volumes for both the sun and the spaceship, and check for sphere-to-sphere collisions. Remember, the steps are:
                            </p>
                            <ol>
                                <li>
                                    Calculate the vector between the two sphere-centres (same as the models' positions)  
                                </li>
                                <li>
                                    Get the length of this vector (the distance between the models)
                                </li>
                                <li>
                                    If this distance is less than the sum of the radii of the two bounding spheres then there is a collision
                                </li>
                                <li>
                                    If a collision is detected, simply resolve it by moving the spaceship to its last known position before the collision occured (lab 8's walkthrough shows how to do this). 
                                </li>
                            </ol>
                            <br/>
                            <p>
                                You can use Week 8's lecture slides, lab sheet or walkthrough as a reference for implementing collision detection and resolution.
                            </p>
                        </div>
                    </li>
                </ol>
            </section>
            <section>
                <h2>6. Using Functions for Collision Detection</h2>
                <div class="section_instrcutions"></div>
                    <ol> 
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                               Right now our program contains sphere to sphere collision detection between the sun and the spaceship. If we were to implement sphere to sphere collision between the spaceship and all the other bodies without using functions, our game-loop could get messy quickly. Let us, therefore, create a sphere to sphere collision detection function that we can call anytime we want to check for a collision between the spaceship and any of the other bodies in our program.  
                            </p>
                        </div>
                    </li> 
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                               The sphere to sphere collision dectection function should check if there is a collision between two objects bounded by spheres. Therefore it needs to know the position of the objects and their radii of the spheres. If there is a collision it should return True, and return False is there is no collision. Use the code below to declare the function, the declaration should be placed before the start of the program's main function
                            </p>
                            <pre><code>bool sphere2Sphere(float s1XPos,  float s1ZPos, float s1Radius, float s2XPos, float s2ZPos, float s2Radius);</code></pre>
                        </div>
                    </li>   
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                Next, use the code provided below to define a sphere2sphere collision detection function below the closing brace of the main function.
                            </p>
<pre><code>bool sphere2Sphere(float s1XPos, float s1ZPos, float s1Radius, float s2XPos, float s2ZPos, float s2Radius) {
        float distX = s2XPos - s1XPos;
        float distZ = s2ZPos - s1ZPos;
        float distance = sqrt(distX*distX + distZ*distZ);
        bool collision;
        if (distance < (s1Radius + s2Radius)) {
            collision = true;
        }
        else {
            collision = false;
        }
    
        return collision;
}</code></pre>
                            <p>
                                The function takes in the x and z positions of two sphere volumes (why do you think the Y position is ignored in this case?) and their radii, calculates the distance between the spheres, compare the distance with the sum of their radii, returns true to show there is a collision if the distance is less than the radii sum, or returns false to show there is no collision if the distance is greater than the radii sum.
                            </p>
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                               You can now call this function inside your game loop to check for collisions. Use the GetX() and GetZ() functions to get the position of an object, and make sure you take scaling into consideration when providing the radius of an object (e.g. a planet that is not scaled has radius 1, a planet scaled up to 2 has radius 2, while a planet scaled down to 0.5 has radius 0.5). An example of the use of the function is shown below:
                            </p>
<pre><code>if(sphere2Sphere(earth->GetX(), earth->GetZ(), 1.0f, spaceship->GetX(), spaceship->GetZ(), 4.0f)){
    myEngine->Stop();
}
</code></pre>
<p>
    The spaceship in its default scale has a radius of about 4.0f, you can get a more exact value using its bounding box coordinates found within its mesh file.
</p>
                        </div>
                    </li>  
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                Using the sphere2sphere function, update your game loop to check for collision between the spaceship and all the bodies in your solar system.
                            </p>
                        </div>
                    </li>
                    <li>
                        <div class="list-div">
                            <p class= "instruction-item">
                                You can reuse this function in other programs. You should also try defining functions for other collision detection approaches so you can easily reuse them.
                            </p>
                        </div>
                    </li>       
                </ol>
            </section>
            <section>
                <h2>APPENDIX</h2>
            <div class="section_instrcutions"></div>
                <ol>     
    
                <li>
                    <div class="list-div">
                            <p class= "instruction-item">AttachToParent() definition:

<pre><code>void AttachToParent(const ISceneNode* Parent);
// E.g. camera->AttachToParent( character );</code></pre>

                            The type 'ISceneNode' is new to you – it represents anything in the scene, including cameras and models. This simply tells you that you can attach anything to anything (although some combinations don’t work yet).
                            </p>
                        </div>
                </li>
                </ol>
        </section>
    </main>
    <script src="https://acodedoer.github.io/CO1301/assets/script.js"></script>
</body>
</html>